import WebSocket from 'ws'; // Corrected import
import { GoogleGenerativeAI, FunctionDeclarationSchemaType, Part, FunctionDeclaration, FunctionDeclarationSchema, GenerateContentRequest, ChatSession, Content } from '@google/generative-ai';
import {
    WebSocketMessage,
    AgentInfo,
    SquadInfo,
    TaskObject,
    AgentCommandObject,
    AgentStatusSnapshot,
    AgentEvent,
    AgentEventType, // Import AgentEventType
    Coordinates
} from '@aetherius/shared-types';

// --- Configuration (Passed via args/env from Orchestrator) ---
const SQUAD_ID = process.env.SQUAD_ID || `squad-unknown-${Math.random().toString(36).substring(2, 8)}`;
const ORCHESTRATOR_ADDRESS = process.env.ORCHESTRATOR_ADDRESS; // Required
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

if (!ORCHESTRATOR_ADDRESS) {
    console.error("FATAL: ORCHESTRATOR_ADDRESS environment variable not set.");
    process.exit(1);
}

console.log(`--- Squad Leader Instance (${SQUAD_ID}) ---`);
console.log(`Orchestrator Address: ${ORCHESTRATOR_ADDRESS}`);

// --- State ---
let missionDescription: string | null = null;
let taskDetails: any = null;
// Store the full latest snapshot and recent events
let assignedAgents: Map<string, {
    agentId: string;
    bsmAddress: string;
    bsmSocket: WebSocket | null;
    latestSnapshot: AgentStatusSnapshot | null; // Store the full snapshot
    recentEvents: string[]; // Store recent event descriptions
}> = new Map();
let orchestratorSocket: WebSocket | null = null;
let isInitialized = false;
let tacticalChatSession: ChatSession | null = null; // Store the chat session
let isPlanningRunActive = false; // Prevent concurrent planning runs
let missionProgress: { [key: string]: 'pending' | 'in_progress' | 'complete' | 'failed' } = {}; // Basic progress tracking
let missionResults: object | null = null; // Store final results

// --- LLM Tactical Core ---
if (!GEMINI_API_KEY) {
    console.warn("WARNING: GEMINI_API_KEY environment variable not set. LLM Tactical Core will not function.");
}
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY || "DUMMY_KEY"); // Use dummy key if not set
const tacticalModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" }); // Or specific version

// --- Define Tools for Gemini Flash ---
const tools: FunctionDeclaration[] = [
    {
        name: "agentCommandBatch",
        description: "Issues a batch of commands to one or more assigned agents.",
        parameters: {
            type: FunctionDeclarationSchemaType.OBJECT,
            properties: {
                commands: {
                    type: FunctionDeclarationSchemaType.ARRAY,
                    description: "An array of commands to issue.",
                    items: {
                        type: FunctionDeclarationSchemaType.OBJECT,
                        properties: {
                            agentId: { type: FunctionDeclarationSchemaType.STRING, description: "The unique ID of the agent to command." },
                            taskId: { type: FunctionDeclarationSchemaType.STRING, description: "A unique identifier for this specific task instance (can be generated by the LLM or Squad Leader)." },
                            task: {
                                type: FunctionDeclarationSchemaType.OBJECT,
                                description: "The TaskObject defining the action.",
                                properties: {
                                    type: { type: FunctionDeclarationSchemaType.STRING, description: "The type of task (e.g., NavigateTo, Gather, Attack).", properties: {} },
                                    details: {
                                        type: FunctionDeclarationSchemaType.OBJECT,
                                        description: "An object containing parameters specific to the task type (e.g., {targetCoords: {x,y,z}} for NavigateTo).",
                                        properties: {}
                                     }
                                },
                                required: ['type', 'details']
                            }
                        },
                        required: ['agentId', 'taskId', 'task']
                    }
                }
            },
            required: ['commands']
        }
    },
    {
        name: "reportStatusToOrchestrator",
        description: "Reports the current status and progress of the squad's mission to the Orchestrator.",
        parameters: {
            type: FunctionDeclarationSchemaType.OBJECT,
            properties: {
                status: { type: FunctionDeclarationSchemaType.STRING, description: "A brief description of the current squad status (e.g., 'Mining iron vein', 'Moving to coordinates')." },
                progress: { type: FunctionDeclarationSchemaType.NUMBER, description: "Estimated mission progress (0.0 to 1.0)." },
                details: { type: FunctionDeclarationSchemaType.OBJECT, description: "Optional object with additional details (e.g., {'iron_collected': 35}).", properties: {} }
            },
            required: ['status', 'progress']
        }
    },
    {
        name: "reportStrategicFindToOrchestrator",
        description: "Reports a strategically significant finding (like an End Portal Frame, Spawner, Village) to the Orchestrator. Use only for important discoveries.",
        parameters: {
            type: FunctionDeclarationSchemaType.OBJECT,
            properties: {
                findingDetails: {
                    type: FunctionDeclarationSchemaType.OBJECT,
                    description: "Details of the finding (e.g., { poiType: 'Spawner', location: {x,y,z} }).",
                    properties: {
                        poiType: { type: FunctionDeclarationSchemaType.STRING, description: "Type of Point of Interest found.", properties: {} },
                        location: {
                            type: FunctionDeclarationSchemaType.OBJECT,
                            description: "Coordinates of the finding.",
                            properties: {
                                x: { type: FunctionDeclarationSchemaType.NUMBER },
                                y: { type: FunctionDeclarationSchemaType.NUMBER },
                                z: { type: FunctionDeclarationSchemaType.NUMBER }
                            },
                            required: ['x', 'y', 'z']
                         }
                    },
                     required: ['poiType', 'location']
                }
            },
            required: ['findingDetails']
        }
    },
    {
        name: "declareMissionComplete",
        description: "Declares that the squad's mission is successfully completed.",
        parameters: {
            type: FunctionDeclarationSchemaType.OBJECT,
            properties: {
                results: { type: FunctionDeclarationSchemaType.OBJECT, description: "An object summarizing the mission results (e.g., {'iron_collected': 52}).", properties: {} }
            },
            required: ['results']
        }
    },
    {
        name: "declareMissionFailed",
        description: "Declares that the squad's mission has failed.",
        parameters: {
            type: FunctionDeclarationSchemaType.OBJECT,
            properties: {
                reason: { type: FunctionDeclarationSchemaType.STRING, description: "A brief explanation of why the mission failed." }
            },
            required: ['reason']
        }
    }
];


async function runTacticalPlanning(triggeringEvent?: any) {
    if (!isInitialized || !GEMINI_API_KEY) {
        console.log("Tactical planning skipped: Not initialized or API key missing.");
        return;
    }
    if (isPlanningRunActive) {
        console.log("Tactical planning skipped: Previous run still active.");
        return;
    }
    isPlanningRunActive = true;

    console.log(`Running tactical planning for Squad ${SQUAD_ID}...`);
    if (triggeringEvent) console.log("Triggering Event:", triggeringEvent);

    try {
        // 1. Initialize Chat Session if needed
        if (!tacticalChatSession) {
            console.log("Initializing new tactical chat session...");
            // Refined System Instruction for Conversational Context
            const systemInstructionText = `You are a Squad Leader AI responsible for the tactical execution of a mission using a team of Minecraft bot agents.
Mission: ${missionDescription || 'Not yet defined'}
Agents: ${Array.from(assignedAgents.keys()).join(', ') || 'None assigned'}

This is an ongoing tactical planning session. Analyze the current mission objective, the latest agent statuses, and recent events provided in each user message.
Your primary goal is to determine the *next immediate tactical steps* required to progress the mission.
Use the available function tools precisely:
- 'agentCommandBatch': Issue specific, actionable commands to agents. Generate unique taskIds.
- 'reportStatusToOrchestrator': Provide concise progress updates.
- 'reportStrategicFindToOrchestrator': Report ONLY truly significant discoveries (Spawners, Portals, Villages, Fortresses).
- 'declareMissionComplete' / 'declareMissionFailed': Use ONLY when the mission objective is definitively met or impossible.

Focus on clear, sequential commands. Avoid vague instructions. Base your decisions *only* on the information provided in the conversation history and the current user message.`;
            const systemInstructionContent: Content = {
                role: "system",
                parts: [{ text: systemInstructionText }]
            };
            tacticalChatSession = tacticalModel.startChat({
                history: [], // Start with empty history
                tools: [{ functionDeclarations: tools }],
                systemInstruction: systemInstructionContent
            });
        }

        // 2. Build User Prompt for this turn (using Markdown)
        let userPromptParts: string[] = [];
        userPromptParts.push(`## Current Turn Context`);
        userPromptParts.push(`**Mission:** ${missionDescription}`);
        if (taskDetails) {
            userPromptParts.push(`**Details:** \`\`\`json\n${JSON.stringify(taskDetails, null, 2)}\n\`\`\``);
        }

        userPromptParts.push(`\n**Agent Status & Recent Events:**`);
        if (assignedAgents.size === 0) {
            userPromptParts.push(`*   (No agents currently assigned)`);
        } else {
            assignedAgents.forEach(agent => {
                let agentStatusLine = `*   **Agent ${agent.agentId}:** `;
                if (agent.latestSnapshot) {
                    const status = agent.latestSnapshot.status;
                    const pos = status.position ? `(${status.position.x.toFixed(1)}, ${status.position.y.toFixed(1)}, ${status.position.z.toFixed(1)})` : '(N/A)';
                    const inv = status.keyInventory ? Object.entries(status.keyInventory).map(([k, v]) => `${k}: ${v}`).join(', ') : 'Empty';
                    agentStatusLine += `At ${pos}, HP: ${status.health}, Hunger: ${status.hunger}, Task: ${status.currentTaskDescription || 'Idle'}, Inv: {${inv}}`;
                } else {
                    agentStatusLine += `(No status snapshot received yet)`;
                }
                const events = agent.recentEvents || [];
                agentStatusLine += ` | Recent: [${events.join('; ')}]`;
                userPromptParts.push(agentStatusLine);
            });
        }

        if (triggeringEvent) {
            userPromptParts.push(`\n**Triggering Event:**`);
            userPromptParts.push(`\`\`\`json\n${JSON.stringify(triggeringEvent, null, 2)}\n\`\`\``);
        }

        userPromptParts.push(`\n**Instruction:**`);
        userPromptParts.push(`Based *only* on the mission, current agent status/events, and the triggering event (if provided), determine the next tactical actions required. Use the available tools to issue commands, report status/findings, or declare mission outcome.`);

        const userPrompt = userPromptParts.join('\n');

        console.log("--- Sending Message to Gemini ---");
        // console.log("User Prompt:\n", userPrompt); // Optional: Log for debugging
        console.log("--- End Message ---");

        // 3. Send message using the chat session and handle response
        const result = await tacticalChatSession.sendMessage(userPrompt);
        const response = result.response;
        const functionCalls = response.functionCalls();

        if (functionCalls && functionCalls.length > 0) {
            console.log(`LLM Response: ${functionCalls.length} function call(s)`);
            // 4. Handle Function Calls
            for (const call of functionCalls) {
                const { name, args } = call;
                console.log(`Executing tool: ${name} with args:`, args);
                switch (name) {
                    case "agentCommandBatch": {
                        const typedArgs = args as { commands?: AgentCommandObject[] };
                        if (typedArgs.commands && Array.isArray(typedArgs.commands)) {
                            sendCommandBatch(typedArgs.commands);
                        } else {
                            console.error("Invalid arguments for agentCommandBatch:", args);
                        }
                        break;
                    }
                    case "reportStatusToOrchestrator": {
                        const typedArgs = args as { status: string; progress: number; details?: object };
                        if (typeof typedArgs.status === 'string' && typeof typedArgs.progress === 'number') {
                            reportStatusToOrchestrator(typedArgs.status, typedArgs.progress, typedArgs.details);
                        } else {
                             console.error("Invalid arguments for reportStatusToOrchestrator:", args);
                        }
                        break;
                    }
                    case "reportStrategicFindToOrchestrator": {
                         const typedArgs = args as { findingDetails: object };
                         if (typedArgs.findingDetails) {
                            reportStrategicFindToOrchestrator(typedArgs.findingDetails);
                         } else {
                             console.error("Invalid arguments for reportStrategicFindToOrchestrator:", args);
                         }
                        break;
                    }
                    case "declareMissionComplete": {
                         const typedArgs = args as { results: object };
                         if (typedArgs.results) {
                            declareMissionComplete(typedArgs.results);
                         } else {
                             console.error("Invalid arguments for declareMissionComplete:", args);
                         }
                        break;
                    }
                    case "declareMissionFailed": {
                         const typedArgs = args as { reason: string };
                         if (typedArgs.reason) {
                            declareMissionFailed(typedArgs.reason);
                         } else {
                             console.error("Invalid arguments for declareMissionFailed:", args);
                         }
                        break;
                    }
                    default:
                        console.warn(`Unknown function call requested by LLM: ${name}`);
                }
            }
        } else {
            console.log("LLM Response: No function calls. Text:", response.text());
            reportStatusToOrchestrator(`LLM Update: ${response.text()}`, -1);
        }
    } catch (error) {
        console.error("Error during tactical planning LLM interaction:", error);
        // Report LLM error to Orchestrator
        const errorMessage = error instanceof Error ? error.message : String(error);
        reportStatusToOrchestrator(`LLM tactical planning failed: ${errorMessage}`, -1, { error: true }); // Use progress -1 or a specific flag
        // Consider declaring mission failed if LLM errors persist, but not automatically on first error.
    } finally {
        isPlanningRunActive = false; // Allow next run
    }
}

// --- Command Dispatch ---
function sendCommandBatch(commands: AgentCommandObject[]) {
    console.log(`Dispatching command batch for Squad ${SQUAD_ID}:`, commands.map(c => `${c.task.type} to ${c.agentId}`));
    commands.forEach(cmd => {
        const agentInfo = assignedAgents.get(cmd.agentId);
        if (agentInfo && agentInfo.bsmSocket && agentInfo.bsmSocket.readyState === WebSocket.OPEN) {
            const message: WebSocketMessage = {
                type: 'squadLeader::agentCommand',
                payload: cmd,
                senderId: SQUAD_ID
            };
            agentInfo.bsmSocket.send(JSON.stringify(message));
        } else {
            console.warn(`Cannot send command to agent ${cmd.agentId}: BSM connection not available or agent not assigned.`);
            // Update agent state to reflect command send failure
            updateAgentSnapshot(cmd.agentId, {
                eventType: 'commandSendFailed' as any, // Use 'as any' until type is added to shared-types
                eventDetails: { taskId: cmd.taskId, taskType: cmd.task.type, reason: 'BSM connection unavailable' }
            });
            // This failure will be included in the 'Recent Events' for the next LLM planning cycle.
        }
    });
}

// --- Reporting to Orchestrator ---
function sendToOrchestrator(message: WebSocketMessage) {
    if (orchestratorSocket && orchestratorSocket.readyState === WebSocket.OPEN) {
        message.senderId = SQUAD_ID; // Ensure senderId is set
        orchestratorSocket.send(JSON.stringify(message));
    } else {
        console.error(`Cannot send message to Orchestrator: WebSocket not connected.`);
        // TODO: Handle failure - queue message? Terminate?
    }
}

function reportStatusToOrchestrator(status: string, progress: number, details?: object) {
    console.log(`Reporting status to Orchestrator: ${status} (${progress * 100}%)`);
    sendToOrchestrator({
        type: 'squadLeader::statusUpdate',
        payload: { squadId: SQUAD_ID, status, progress, details }
    });
}

function reportStrategicFindToOrchestrator(findingDetails: object) {
     console.log(`Reporting strategic find to Orchestrator:`, findingDetails);
     sendToOrchestrator({
        type: 'squadLeader::reportStrategicFind',
        payload: { squadId: SQUAD_ID, findingDetails }
    });
}

function declareMissionComplete(results: object) {
    console.log(`Declaring mission complete to Orchestrator.`);
    missionResults = results; // Store the final results
    missionProgress['overall'] = 'complete';
     sendToOrchestrator({
        type: 'squadLeader::missionComplete',
        payload: { squadId: SQUAD_ID, results }
    });
}

function declareMissionFailed(reason: string) {
     console.log(`Declaring mission failed to Orchestrator: ${reason}`);
     missionProgress['overall'] = 'failed';
     sendToOrchestrator({
        type: 'squadLeader::missionFailed',
        payload: { squadId: SQUAD_ID, reason }
    });
}


// --- WebSocket Connection to Orchestrator ---
function connectToOrchestrator() {
    console.log(`Connecting to Orchestrator at ${ORCHESTRATOR_ADDRESS}...`);
    if (!ORCHESTRATOR_ADDRESS) {
        console.error("Orchestrator address is unexpectedly undefined during connection attempt.");
        shutdown(1);
        return;
    }
    orchestratorSocket = new WebSocket(ORCHESTRATOR_ADDRESS);

    orchestratorSocket.on('open', () => { // Correct event handling
        console.log('Connected to Orchestrator.');
        const registrationMessage: WebSocketMessage = {
            type: 'squadLeader::register',
            senderId: SQUAD_ID,
            payload: {}
        };
        orchestratorSocket?.send(JSON.stringify(registrationMessage));
    });

    orchestratorSocket.on('message', (message: Buffer) => { // Correct event handling
        try {
            const parsedMessage: WebSocketMessage = JSON.parse(message.toString());
            console.log(`Received message from Orchestrator: ${parsedMessage.type}`);

            if (parsedMessage.type === 'squadLeader::init' && !isInitialized) {
                handleInitialization(parsedMessage.payload);
            } else if (parsedMessage.type === 'squadLeader::terminate') {
                console.log('Received terminate signal from Orchestrator.');
                shutdown();
            }
        } catch (error) {
            console.error('Failed to parse Orchestrator message or handle:', error);
        }
    });

    orchestratorSocket.on('close', () => { // Correct event handling
        console.error('Disconnected from Orchestrator. Terminating.');
        orchestratorSocket = null;
        shutdown(1);
    });

    orchestratorSocket.on('error', (error: Error) => { // Correct event handling
        console.error('Orchestrator WebSocket error:', error);
        orchestratorSocket = null;
        shutdown(1);
    });
}

// --- WebSocket Connections to BSMs ---
const MAX_RECONNECT_ATTEMPTS = 3;
const RECONNECT_DELAY_MS = 5000;

function connectToBSMs(agentsToConnect: { agentId: string; bsmAddress: string }[]) {
    console.log('Connecting to BSMs for assigned agents...');
    agentsToConnect.forEach(agentInitInfo => {
        connectSingleBSM(agentInitInfo.agentId, agentInitInfo.bsmAddress, 0);
    });
}

function connectSingleBSM(agentId: string, bsmAddress: string, attempt: number) {
    const agentState = assignedAgents.get(agentId);
    if (!agentState) {
        console.warn(`Agent ${agentId} no longer assigned, skipping BSM connection.`);
        return;
    }
    if (agentState.bsmSocket && agentState.bsmSocket.readyState === WebSocket.OPEN) {
        console.log(`BSM connection for agent ${agentId} already open.`);
        return;
    }

    console.log(`Connecting to BSM at ${bsmAddress} for agent ${agentId} (Attempt ${attempt + 1}/${MAX_RECONNECT_ATTEMPTS + 1})`);
    const bsmWs = new WebSocket(bsmAddress);
    agentState.bsmSocket = bsmWs;

    bsmWs.on('open', () => { // Correct event handling
        console.log(`Connected to BSM for agent ${agentId}`);
    });

    bsmWs.on('message', (message: Buffer) => { // Correct event handling
        try {
            const parsedMessage: WebSocketMessage<AgentEvent | AgentStatusSnapshot> = JSON.parse(message.toString());
            // console.log(`Received message from BSM (via Agent ${agentId}): ${parsedMessage.type}`);

            if (parsedMessage.type.startsWith('agent::event::')) {
                const event = parsedMessage.payload as AgentEvent;
                // Use the imported AgentEventType for type safety
                updateAgentSnapshot(agentId, { eventType: event.eventType as AgentEventType, eventDetails: event.details });
                if (event.eventType === 'foundPOI' && isStrategicFinding(event.details)) {
                    reportStrategicFindToOrchestrator(event.details);
                }
                if (isSignificantAgentEvent(event.eventType as AgentEventType)) {
                    runTacticalPlanning({ type: 'agentEvent', agentId, event });
                }
            } else if (parsedMessage.type === 'agent::statusUpdate') {
                const snapshot = parsedMessage.payload as AgentStatusSnapshot;
                updateAgentSnapshot(agentId, { snapshot });
                // runTacticalPlanning({ type: 'agentStatusUpdate', agentId, snapshot });
            }

        } catch (error) {
            console.error(`Failed to parse BSM message for agent ${agentId}:`, error);
        }
    });

    const handleDisconnect = (isError: boolean) => {
        // Check agentState again inside handler as it might have changed
        const currentAgentState = assignedAgents.get(agentId);
        if (!currentAgentState || !currentAgentState.bsmSocket) return; // Already handled or agent removed

        currentAgentState.bsmSocket = null; // Clear the socket state

        if (attempt < MAX_RECONNECT_ATTEMPTS) {
            console.warn(`BSM for ${agentId} ${isError ? 'errored' : 'closed'}. Attempting reconnect (${attempt + 2}/${MAX_RECONNECT_ATTEMPTS + 1}) in ${RECONNECT_DELAY_MS}ms...`);
            setTimeout(() => connectSingleBSM(agentId, bsmAddress, attempt + 1), RECONNECT_DELAY_MS);
        } else {
            console.error(`BSM for ${agentId} disconnected permanently after ${MAX_RECONNECT_ATTEMPTS + 1} attempts.`);
            // Update state to reflect permanent loss - Use a specific event type if defined, otherwise a string
            // We need to add 'agentLostConnection' to AgentEventType in shared-types
            updateAgentSnapshot(agentId, { eventType: 'agentLostConnection' as any }); // Use 'as any' temporarily
            // Report to Orchestrator
            sendToOrchestrator({
                type: 'squadLeader::agentLost',
                payload: { squadId: SQUAD_ID, agentId: agentId, reason: 'BSM connection lost permanently' }
            });
            // Trigger planning to adapt
            runTacticalPlanning({ type: 'agentLostConnection', agentId });
        }
    };

    bsmWs.on('close', () => handleDisconnect(false)); // Correct event handling
    bsmWs.on('error', (error: Error) => { // Correct event handling
        console.error(`BSM WebSocket error for agent ${agentId}:`, error.message);
        handleDisconnect(true);
    });
}

// --- Initialization Handler ---
function handleInitialization(payload: any) {
    console.log('Received initialization payload:', payload);
    missionDescription = payload.missionDescription;
    taskDetails = payload.taskDetails;
    missionProgress = {}; // Reset progress for new mission
    missionResults = null; // Reset results
    const agentsToAssign: { agentId: string; bsmAddress: string }[] = payload.assignedAgents || [];

    // TODO: Potentially parse taskDetails here to initialize missionProgress stages if applicable

    agentsToAssign.forEach(a => {
        // Initialize agent state correctly
        assignedAgents.set(a.agentId, {
            ...a,
            bsmSocket: null,
            latestSnapshot: null, // Initialize snapshot as null
            recentEvents: [] // Initialize recentEvents
        });
    });

    isInitialized = true;
    console.log(`Squad ${SQUAD_ID} initialized for mission: ${missionDescription}`);
    reportStatusToOrchestrator("Initialized", 0.1);

    // Connect to BSMs for the assigned agents
    connectToBSMs(agentsToAssign);

    // Trigger initial tactical planning
    runTacticalPlanning({ type: 'initialization' });
}

// --- Helper Functions ---
// Update function to handle storing full snapshots and adding to recentEvents
// Use AgentEventType | string to allow custom event types like 'agentLostConnection' temporarily
function updateAgentSnapshot(agentId: string, updates: { snapshot?: AgentStatusSnapshot, eventType?: AgentEventType | string, eventDetails?: any }) {
    const agentInfo = assignedAgents.get(agentId);
    if (agentInfo) {
        const { snapshot, eventType, eventDetails } = updates;

        // Store the full snapshot if provided
        if (snapshot) {
            agentInfo.latestSnapshot = snapshot;
            // console.log(`Updated snapshot for ${agentId}:`, agentInfo.latestSnapshot);
        }

        // Add event type to recentEvents, keeping the list short
        if (eventType) {
            let detailsString = '';
            if (eventDetails) {
                try {
                    detailsString = JSON.stringify(eventDetails);
                    if (detailsString.length > 100) {
                        detailsString = detailsString.substring(0, 97) + '...';
                    }
                } catch (e) { detailsString = '[unserializable]'; }
            }
            const eventDescription = `${new Date().toLocaleTimeString()} - ${eventType}${detailsString ? `: ${detailsString}` : ''}`;

            if (!agentInfo.recentEvents) {
                agentInfo.recentEvents = [];
            }
            agentInfo.recentEvents.push(eventDescription);

            if (agentInfo.recentEvents.length > 7) {
                agentInfo.recentEvents.shift();
            }
        }
    }
}

function isStrategicFinding(details: any): boolean {
    const strategicTypes = ["minecraft:end_portal_frame", "minecraft:spawner", "minecraft:village", "minecraft:nether_fortress"];
    return details && details.poiType && strategicTypes.includes(details.poiType);
}

// Use AgentEventType for stricter checking
function isSignificantAgentEvent(eventType: AgentEventType): boolean {
    const significantEvents: AgentEventType[] = [
        'taskComplete',
        'taskFailed',
        'detectedThreat',
        'tookDamage',
        // Add others from AgentEventType as needed
    ];
    // Exclude custom string types like 'agentLostConnection' from triggering planning directly here
    if (typeof eventType !== 'string' || !significantEvents.includes(eventType)) {
         return false;
    }
    return significantEvents.includes(eventType);
}


// --- Main Execution ---
connectToOrchestrator();

// --- Graceful Shutdown ---
let isShuttingDown = false;
function shutdown(exitCode = 0) {
    if (isShuttingDown) return;
    isShuttingDown = true;
    console.log(`Squad Leader ${SQUAD_ID} shutting down...`);

    assignedAgents.forEach(agent => {
        agent.bsmSocket?.close();
    });
    orchestratorSocket?.close();

    console.log(`Squad Leader ${SQUAD_ID} shutdown complete.`);
    setTimeout(() => process.exit(exitCode), 500);
}

process.on('SIGTERM', () => shutdown(0));
process.on('SIGINT', () => shutdown(0));
process.on('uncaughtException', (error) => {
    console.error('UNCAUGHT EXCEPTION:', error);
    shutdown(1);
});
process.on('unhandledRejection', (reason, promise) => {
    console.error('UNHANDLED REJECTION:', reason);
    shutdown(1);
});